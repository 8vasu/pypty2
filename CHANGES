v1 -> v2

Lib/tty.py -> ./tty.py:
	+ mode_raw()
	+ login()
	setraw():
		+ return original termios to avoid multiple tcgetattr calls

Lib/pty.py -> ./pty2.py:
	- master_open()
	- slave_open()
	fork():
		- some parts of fallback code
		+ use tty.login() in fallback code as replacement
	+ _getmask()
	+ _sigblock()
	+ _sigreset()
	+ _winresz()
	+ _termset()
	+ _winset()
	_copy() -> _mainloop():
		+ catch OSError while reading from master and return
	spawn():
		+ set slave termios
		+ set slave winsize
		+ register SIGWINCH handler
		- use pty.fork()
		+ use pty.openpty()
		+ use os.fork()
		+ use tty.login()
		+ block signals except during select.select() in _mainloop() and during os.waitpid();
		  even the SIGWINCH handler blocks signals to avoid os.close() failing on a slave descriptor;
		  if any descriptor of the slave remains open, _mainloop() will not terminate on Linux